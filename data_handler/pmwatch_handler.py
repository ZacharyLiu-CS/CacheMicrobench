#!/usr/bin/env python3

# This script is used to extract the targeted information from the outpfile.csv generated by intel-pmwatch
# Here is the docs url of intel-pmwatch https://github.com/intel/intel-pmwatch/blob/master/docs/README

import argparse
import subprocess
from pprint import pprint
import re


def get_nvdimm_topology() -> dict:
    shell_command = ['sudo', 'pmwatch', '-a']
    result = subprocess.run(
        shell_command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    output_list = result.stdout.decode('utf-8').split('\n')
    nvdimm_nums = int((re.findall(r'\d+', output_list[3])[-1]))
    nvdimm_dict = {}
    for i in range(0, nvdimm_nums):
        nvdimm_details = output_list[4+i]
        numa_node = int((re.findall(r'\d+', nvdimm_details)[0]))
        nvdimm_name = re.findall(r'DIMM[^"]*', nvdimm_details)[0]
        if numa_node not in nvdimm_dict:
            nvdimm_dict[numa_node] = set()
        nvdimm_dict[numa_node].add(nvdimm_name)
    return nvdimm_dict


def extract_data_from_csv(file_path, numa_node, nvdimm_topology):
    pmwatch_log_list = []
    alldata_timeseries = {}
    with open(file_path, 'r') as f:
        pmwatch_log_list = f.readlines()

    # get from the imestamp;;DIMM0;;;;;;;;;;DIMM1...
    nvdimm_nodes = pmwatch_log_list[5].split(';')
    metrics_types = pmwatch_log_list[6].split(';')

    # seperate data in a line like 1;2;3 to [1,2,3]
    for line in range(7, len(pmwatch_log_list)):
        pmwatch_log_list[line] = pmwatch_log_list[line].split(";")

    # get the dimm data start index [timestamp;;dim1;;;dim2] -> [2,5]
    nvdimm_nodes_start = [nvdimm_nodes.index(
        i) for i in nvdimm_nodes if i in nvdimm_topology[numa_node]]

    # extract each nvdimm data
    for i in nvdimm_nodes_start:
        metrics_length = 10
        metrics_list = metrics_types[i:i+metrics_length]
        metrics_data = {}
        # get all data of one specific metric type one by one
        for metric in metrics_list:
            # caculate the index of specfic type
            metric_index = i + metrics_list.index(metric)
            metrics_data[metric] = [float(
                pmwatch_log_list[line][metric_index]) for line in range(7, len(pmwatch_log_list))]
        alldata_timeseries[nvdimm_nodes[i]] = metrics_data
    return alldata_timeseries


def filter_by_operation_type(data_list, operation_type):
    for nvdimm in data_list:
        nvdimm_data = data_list[nvdimm].copy()
        for metrics_type in nvdimm_data:
            if operation_type not in metrics_type:
                data_list[nvdimm].pop(metrics_type)
    return data_list


def add_two_list(list1, list2):
    return list(map(lambda x: x[0]+x[1], zip(list1, list2)))


def combine_data_in_single_numa_node(data_list, present_type):
    if present_type == "single":
        return data_list
    combined_list = {}
    for nvdimm in data_list:
        for metric in data_list[nvdimm]:
            if metric not in combined_list:
                combined_list[metric] = [0 for _ in data_list[nvdimm][metric]]
            combined_list[metric] = add_two_list(
                combined_list[metric], data_list[nvdimm][metric])
    return combined_list


def parse_option():
    """Parse command line opetion"""
    # arg parser
    parser = argparse.ArgumentParser()
    parser.add_argument('--file_path', '-f', nargs='?', default="./pm_output.csv",
                        help='the output file path generated by intel-pmwatch')
    parser.add_argument('--numa_node', '-n', nargs='?', choices=[-1, 0, 1, 2, 3], default=0,
                        help='numa node of the targeted dimm, -1 means output all nodes')
    # bytes_read (derived)	bytes_written (derived)
    # read_hit_ratio (derived)	write_hit_ratio (derived)
    # media_read_ops (derived)	media_write_ops (derived)
    # read_64B_ops_received	write_64B_ops_received
    # cpu_read_ops	cpu_write_ops

    parser.add_argument('--operation_type', '-t', nargs='?', choices=['bytes_read', 'bytes_written',
                                                                      'read_hit_ratio', 'write_hit_ratio',
                                                                      'media_read_ops', 'media_write_ops',
                                                                      'read_64B_ops_received', 'write_64B_ops_received',
                                                                      'cpu_read_ops', 'cpu_write_ops'], default='bytes_written',
                        help='the target operation type')
    parser.add_argument('--present_type', '-p', nargs='?', choices=['combined', 'single'], default='combined',
                        help='the present type, single means output single metrics of each nvdimm')
    # parse args
    args = parser.parse_args()
    file_path = args.file_path
    numa_node = args.numa_node
    operation_type = args.operation_type
    present_type = args.present_type

    # return args
    return (file_path, numa_node, operation_type, present_type)


if __name__ == "__main__":
    (file_path, numa_node, operation_type, present_type) = parse_option()
    nvdimm_topology = get_nvdimm_topology()
    csv_data = extract_data_from_csv(file_path, numa_node, nvdimm_topology)
    csv_filtered_data = filter_by_operation_type(csv_data, operation_type)
    analysed_data = combine_data_in_single_numa_node(
        csv_filtered_data, present_type)
    pprint(analysed_data)
